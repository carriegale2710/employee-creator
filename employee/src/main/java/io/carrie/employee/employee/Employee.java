package io.carrie.employee.employee;

import io.carrie.employee.contract.Contract;
import io.carrie.employee.employee.enums.EmployeeStatus;

import java.time.LocalDate;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.*;

// Lombok
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString

@Entity
@Table(name = "employees")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column
    private String firstName;

    @Column
    private String lastName;

    @Column(unique = true)
    private String email;

    @Column
    private String phone; // keep original format

    @Column
    private String address; // dto validation later if needed

    @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // Prevent circular references
    @JsonIgnoreProperties({ "employee", "contract" })
    @ToString.Exclude
    @Getter(AccessLevel.NONE) // use custom getters below
    @Setter(AccessLevel.PACKAGE) // Allow JPA access but not public
    private List<Contract> contracts;

    // NOTE - basic getters and setters, constructors are all generated by Lombok

    // ! SECTION - Custom domain business logic: contract access methods

    public EmployeeStatus getStatus() {

        if (hasActiveContract())
            return EmployeeStatus.ACTIVE;

        // eg. "Is this employee new ?"
        if (getContractCount() == 1)
            return EmployeeStatus.NEW_HIRE;

        return EmployeeStatus.INACTIVE; // safer assumption
    }

    public boolean hasActiveContract() {
        // eg. "Is this still hired in our company?"
        return getAllContracts().stream()
                .anyMatch(Contract::isActive); // virtual field in 'Contract'
    }

    public LocalDate getContractEndDate() {
        // eg. "Does this employee need a contract renewal soon?"
        return getLatestContract() != null ? getLatestContract().getEndDate() : null;
    }

    public int getContractCount() {
        return getAllContracts().size();
    }

    // !SECTION Private helper methods - employee<->contract business logic

    private List<Contract> getAllContracts() {
        // logic: "View all contracts made for this employee"
        return (contracts != null ? contracts : List.<Contract>of()).stream()
                .sorted((c1, c2) -> c2.getStartDate().compareTo(c1.getStartDate())) // Latest first
                .toList();
    }

    private List<Contract> getActiveContracts() {
        // easy filtering
        return getAllContracts().stream()
                .filter(Contract::isActive)
                .toList();
    }

    private Contract getLatestContract() {
        // Get the most recent contract (active or inactive)
        // usecase: "When did this employee leave our company?"
        return getAllContracts().stream()
                .findFirst()
                .orElse(null);
    }

    // NOTE - Footnote: calling on the contracts entity here is inefficient
    // because both employees AND contracts tables rely on each other to exist
    // this is fine for small-mid sized companies with less than 200 employees,
    // but for loading larger databases eg 10,000 employees
    // this would be slow loading significantly!
    // Solution? Consider moving this logic to 'services' layer instead!!

}